// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3397.UnamedRobot.subsystems;

import org.usfirst.frc3397.UnamedRobot.OI;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.drive.MecanumDrive;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private VictorSP rightRear;
    private VictorSP rightFront;
    private VictorSP leftFront;
    private VictorSP leftRear;
    private MecanumDrive chassis;
    private OI controlScheme = new OI(0, 1);
    private AnalogInput ultra = new AnalogInput(0);
    Timer switchTimer;
    boolean hatchDriveMode;
    int numberOfTimes;
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public DriveTrain() {
        System.out.println("DriveTrain started");
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        rightRear = new VictorSP(0);
        rightFront = new VictorSP(1);
        leftFront = new VictorSP(2);
        leftRear = new VictorSP(3);
        chassis = new MecanumDrive(leftFront, leftRear,
              rightFront, rightRear);
        
            chassis.setSafetyEnabled(true);
            chassis.setExpiration(0.1);
            chassis.setMaxOutput(1.0);
        rightRear.set(.4);
        hatchDriveMode = false;
        numberOfTimes = 1;
        switchTimer = new Timer();
        switchTimer.start();
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }
    public void MecanumDrive() {
        System.out.println(ultra.getVoltage());
        double forward;
        double strafe;
        double turn;
        if (controlScheme.switchFrontNBack() && switchTimer.get() > 1){
            switchTimer.reset();
            System.out.println("Switching to HatchDriveMode");
            hatchDriveMode = !hatchDriveMode;
        } 
        if (!hatchDriveMode){
            forward = controlScheme.getForward();
            strafe = controlScheme.getStrafe();
            turn = -controlScheme.getTurn();
        } else {
            forward = -controlScheme.getForward();
            strafe = controlScheme.getStrafe();
            turn = controlScheme.getTurn();
        }
        
         
        double turnSpeed = 0.5;
        double speedMultiplier = 0.3;
        double deadzone = 0.2;
        
        if (Math.abs(forward) <= deadzone) {
            forward = 0.0;
        }
        
        if (Math.abs(strafe) <= deadzone) {
            strafe = 0.0;
        }
        if (Math.abs(turn) <= deadzone) {
            turn = 0.0;
        }
        
        if (Math.abs(forward) >= deadzone || Math.abs(strafe) >= deadzone) 
        { 
            
//			
            
            
            forward *= speedMultiplier;
            strafe *= speedMultiplier;
            
            
			chassis.driveCartesian(strafe, forward, 0.0);
//			frontLeftMotor.set(forward);
//			frontRightMotor.set(-forward);
//			backLeftMotor.set(forward);
//			backRightMotor.set(-forward);
            
            
        }

        else if (Math.abs(turn) >= deadzone) {
            turn *= -speedMultiplier;
           
            
            chassis.driveCartesian(0.0,  0.0,  turn);
            
        }
        else
        {
            chassis.driveCartesian(0.0, 0.0, 0.0);
        }
    }

    public void Drive(double speed) {
        speed *= -.5;
        chassis.driveCartesian(speed, 0.0, 0.0);
    }
    
    public void stop() {
        chassis.driveCartesian(0.0, 0.0, 0.0);
    }
    
    public void Strafe(double speed) {
        speed *= -1;
        chassis.driveCartesian(0, speed, 0);
    }
    public void Turn(double speed, double gyroAngle) {
        speed *= 1;
        chassis.driveCartesian(0, 0, speed, gyroAngle);
        
    }
    public void runRightRear(int time) throws Exception {
        rightRear.set(.3);
        Thread.sleep(time*1000);
        rightRear.set(0);
    }
   
    public void runLeftRear(int time) throws Exception {
        leftRear.set(-.3);
        Thread.sleep(time*1000);
        leftRear.set(0);
    }
   
    public void runRightFront(int time) throws Exception {
        rightFront.set(.3);
        Thread.sleep(time*1000);
        rightFront.set(0);
    }
   
    public void runLeftFront(int time) throws Exception {
        leftFront.set(-.3);
        Thread.sleep(time*1000);
        leftFront.set(0);
    }
   
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}


